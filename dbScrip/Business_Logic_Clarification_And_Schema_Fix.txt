=============================================
BUSINESS LOGIC CLARIFICATION & SCHEMA FIX
Daily Delivery Columns & Empty/Damaged Tracking
=============================================

IDENTIFIED ISSUES:
1. Empty/Damaged cylinders NOT tracked per product (only at delivery level)
2. Confusion about 4 columns: Cylinders, Invoices, Deliveries, Items

=============================================
PART 1: COLUMN BUSINESS LOGIC CLARIFICATION
=============================================

CURRENT 4 COLUMNS IN DailyDeliveryItems TABLE:
-----------------------------------------------

1. **NoOfCylinders** (INT)
   - WHEN: Product is a CYLINDER (Gas Cylinder category)
   - WHAT: Number of cylinder units
   - EXAMPLE: 10 × 19kg Commercial Cylinders
   - VALUE: 10

2. **NoOfInvoices** (INT)
   - WHEN: Used for ALL product types
   - WHAT: Number of customer invoices/bills for this product
   - EXAMPLE: Delivering to 5 customers, each getting 2 cylinders
   - VALUE: 5 (5 invoices)
   - NOTE: This counts CUSTOMERS, not quantity

3. **NoOfDeliveries** (INT)  ⚠️ AMBIGUOUS - NEEDS CLARIFICATION
   - POSSIBLE MEANING A: Number of delivery addresses/stops
   - POSSIBLE MEANING B: Number of successful delivery transactions
   - POSSIBLE MEANING C: Number of delivery trips required
   - RECOMMENDATION: Clarify with business team what this represents
   - COMMON USE: Usually same as NoOfInvoices OR delivery route stops

4. **NoOfItems** (INT)
   - WHEN: Product is an ACCESSORY (non-cylinder category)
   - WHAT: Number of accessory units
   - EXAMPLE: 15 × Gas Regulators
   - VALUE: 15

DECISION MATRIX:
----------------

| Product Type  | Category   | NoOfCylinders | NoOfInvoices | NoOfDeliveries | NoOfItems |
|---------------|------------|---------------|--------------|----------------|-----------|
| Gas Cylinder  | Cylinder   | 50            | 10           | 10             | NULL/0    |
| Regulator     | Accessory  | NULL/0        | 8            | 8              | 25        |
| Rubber Tube   | Accessory  | NULL/0        | 5            | 5              | 15        |

EXAMPLE SCENARIO:
-----------------
**Delivery contains:**
- 50 × 19kg Cylinders delivered to 10 customers
- 25 × Gas Regulators delivered to 8 customers
- 15 × Rubber Tubes delivered to 5 customers

**DailyDeliveryItems records:**
```
ProductId=1 (19kg Cylinder):  NoOfCylinders=50, NoOfInvoices=10, NoOfDeliveries=10, NoOfItems=0
ProductId=3 (Gas Regulator):  NoOfCylinders=0,  NoOfInvoices=8,  NoOfDeliveries=8,  NoOfItems=25
ProductId=4 (Rubber Tube):    NoOfCylinders=0,  NoOfInvoices=5,  NoOfDeliveries=5,  NoOfItems=15
```

=============================================
PART 2: EMPTY/DAMAGED TRACKING - SCHEMA FIX
=============================================

CURRENT PROBLEM:
----------------
DailyDeliveryItemActuals table tracks:
- PlannedQuantity ✅
- DeliveredQuantity ✅
- PendingQuantity ✅
- CashCollected ✅

BUT MISSING:
- EmptyReturned ❌ (per product)
- DamagedReturned ❌ (per product)

This means you can't answer: "Which product had damaged returns?"

REQUIRED SCHEMA CHANGE:
-----------------------

ALTER TABLE DailyDeliveryItemActuals:
Add 2 columns to track returns per product

```sql
-- Add columns to existing table
ALTER TABLE DailyDeliveryItemActuals
ADD EmptyReturned INT NOT NULL DEFAULT 0,
    DamagedReturned INT NOT NULL DEFAULT 0;
```

UPDATED TABLE STRUCTURE:
------------------------
```sql
CREATE TABLE DailyDeliveryItemActuals (
    ActualId INT IDENTITY(1,1) PRIMARY KEY,
    DeliveryId INT NOT NULL,
    ProductId INT NOT NULL,
    PlannedQuantity INT NOT NULL,
    DeliveredQuantity INT NOT NULL DEFAULT 0,
    PendingQuantity INT NOT NULL DEFAULT 0,
    EmptyReturned INT NOT NULL DEFAULT 0,        -- ✨ NEW
    DamagedReturned INT NOT NULL DEFAULT 0,      -- ✨ NEW
    CashCollected DECIMAL(18,2) DEFAULT 0,
    ItemStatus NVARCHAR(20) DEFAULT 'Pending',
    Remarks NVARCHAR(500),
    UpdatedAt DATETIME DEFAULT GETDATE(),
    CONSTRAINT FK_Actuals_DailyDelivery FOREIGN KEY (DeliveryId) REFERENCES DailyDelivery(DeliveryId),
    CONSTRAINT FK_Actuals_Products FOREIGN KEY (ProductId) REFERENCES Products(ProductId),
    CONSTRAINT UQ_DeliveryProduct UNIQUE (DeliveryId, ProductId)
);
```

=============================================
PART 3: UI UPDATE - ADD EMPTY/DAMAGED COLUMNS
=============================================

CURRENT UI (Item-Wise Delivery Status Table):
----------------------------------------------
| Product Name | Planned | Delivered | Pending | Cash | Status |

UPDATED UI (should be):
-----------------------
| Product Name | Planned | Delivered | Pending | Empty Returned | Damaged | Cash | Status |

EXAMPLE DATA:
-------------
| Product        | Planned | Delivered | Pending | Empty | Damaged | Cash   | Status    |
|----------------|---------|-----------|---------|-------|---------|--------|-----------|
| 19kg Cylinder  | 50      | 48        | 2       | 45    | 3       | 24,000 | Partial   |
| Gas Regulator  | 25      | 25        | 0       | 0     | 0       | 5,000  | Completed |

EXPLANATION:
- 50 cylinders planned
- 48 delivered successfully
- 2 pending (not delivered)
- 45 empty cylinders returned from previous deliveries
- 3 damaged cylinders
- Total cylinders accounted: 48 (out) + 45 (empty back) + 3 (damaged) + 2 (pending) = 98... wait, this doesn't balance.

CORRECT UNDERSTANDING:
----------------------
Empty and damaged are SEPARATE from the delivery:
- **Delivered:** New filled cylinders given to customers (48)
- **Empty Returned:** Old empty cylinders brought back by driver (45)
- **Damaged:** Damaged cylinders found during delivery (3)

Stock impact:
- FilledStock decreases by 48 (delivered)
- EmptyStock increases by 45 (returned)
- DamagedStock increases by 3 (damaged found)

=============================================
PART 4: COMPLETE SQL MIGRATION SCRIPT
=============================================

Execute this to add empty/damaged tracking:

```sql
USE [sandhyaflames]
GO

-- Step 1: Add columns to DailyDeliveryItemActuals table
IF NOT EXISTS (
    SELECT * FROM INFORMATION_SCHEMA.COLUMNS 
    WHERE TABLE_NAME = 'DailyDeliveryItemActuals' 
    AND COLUMN_NAME = 'EmptyReturned'
)
BEGIN
    ALTER TABLE DailyDeliveryItemActuals
    ADD EmptyReturned INT NOT NULL DEFAULT 0;
    
    PRINT 'Added EmptyReturned column';
END

IF NOT EXISTS (
    SELECT * FROM INFORMATION_SCHEMA.COLUMNS 
    WHERE TABLE_NAME = 'DailyDeliveryItemActuals' 
    AND COLUMN_NAME = 'DamagedReturned'
)
BEGIN
    ALTER TABLE DailyDeliveryItemActuals
    ADD DamagedReturned INT NOT NULL DEFAULT 0;
    
    PRINT 'Added DamagedReturned column';
END
GO

-- Step 2: Update sp_GetDeliveryItemActuals to include new columns
CREATE OR ALTER PROCEDURE [dbo].[sp_GetDeliveryItemActuals]
    @DeliveryId INT
AS
BEGIN
    SET NOCOUNT ON;
    
    SELECT 
        a.ActualId,
        a.DeliveryId,
        a.ProductId,
        p.ProductName,
        ISNULL(sc.SubCategoryName, c.CategoryName) AS CategoryName,
        a.PlannedQuantity,
        a.DeliveredQuantity,
        a.PendingQuantity,
        a.EmptyReturned,        -- ✨ NEW
        a.DamagedReturned,      -- ✨ NEW
        a.CashCollected,
        a.ItemStatus,
        a.Remarks,
        a.UpdatedAt,
        di.SellingPriceAtDelivery AS UnitPrice,
        (a.DeliveredQuantity * di.SellingPriceAtDelivery) AS TotalAmount
    FROM dbo.DailyDeliveryItemActuals a
    INNER JOIN dbo.Products p ON a.ProductId = p.ProductId
    INNER JOIN dbo.DailyDeliveryItems di ON a.DeliveryId = di.DeliveryId AND a.ProductId = di.ProductId
    LEFT JOIN dbo.ProductCategories c ON p.CategoryId = c.CategoryId
    LEFT JOIN dbo.ProductSubCategories sc ON p.SubCategoryId = sc.SubCategoryId
    WHERE a.DeliveryId = @DeliveryId
    ORDER BY p.ProductName;
END
GO

-- Step 3: Update sp_UpdateDeliveryItemActuals to accept new columns
CREATE OR ALTER PROCEDURE [dbo].[sp_UpdateDeliveryItemActuals]
    @DeliveryId INT,
    @ItemsJson NVARCHAR(MAX)
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;

    BEGIN TRY
        BEGIN TRANSACTION;

        -- Parse JSON with new columns
        -- Expected: [{"productId":1,"delivered":48,"pending":2,"emptyReturned":45,"damagedReturned":3,"cashCollected":24000}]
        DECLARE @ItemsTable TABLE (
            ProductId INT,
            DeliveredQuantity INT,
            PendingQuantity INT,
            EmptyReturned INT,          -- ✨ NEW
            DamagedReturned INT,        -- ✨ NEW
            CashCollected DECIMAL(18,2),
            Remarks NVARCHAR(500)
        );

        INSERT INTO @ItemsTable
        SELECT 
            ProductId,
            DeliveredQuantity,
            PendingQuantity,
            ISNULL(EmptyReturned, 0),    -- ✨ NEW
            ISNULL(DamagedReturned, 0),  -- ✨ NEW
            ISNULL(CashCollected, 0),
            Remarks
        FROM OPENJSON(@ItemsJson)
        WITH (
            ProductId INT,
            DeliveredQuantity INT,
            PendingQuantity INT,
            EmptyReturned INT,           -- ✨ NEW
            DamagedReturned INT,         -- ✨ NEW
            CashCollected DECIMAL(18,2),
            Remarks NVARCHAR(500)
        );

        -- Update actuals
        UPDATE a
        SET 
            DeliveredQuantity = t.DeliveredQuantity,
            PendingQuantity = t.PendingQuantity,
            EmptyReturned = t.EmptyReturned,        -- ✨ NEW
            DamagedReturned = t.DamagedReturned,    -- ✨ NEW
            CashCollected = t.CashCollected,
            Remarks = t.Remarks,
            ItemStatus = CASE 
                WHEN t.DeliveredQuantity = a.PlannedQuantity THEN 'Completed'
                WHEN t.DeliveredQuantity > 0 THEN 'Partial'
                ELSE 'Pending'
            END,
            UpdatedAt = GETDATE()
        FROM dbo.DailyDeliveryItemActuals a
        INNER JOIN @ItemsTable t ON a.ProductId = t.ProductId
        WHERE a.DeliveryId = @DeliveryId;

        SELECT 1 AS success, 'Item actuals updated successfully' AS message;

        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
            
        SELECT 0 AS success, ERROR_MESSAGE() AS message;
    END CATCH
END
GO

PRINT 'Schema updated successfully!';
```

=============================================
PART 5: ANGULAR MODEL UPDATE
=============================================

FILE: src/app/models/daily-delivery-item-actual.model.ts

UPDATE DailyDeliveryItemActual interface:

```typescript
export interface DailyDeliveryItemActual {
  actualId: number;
  deliveryId: number;
  productId: number;
  productName: string;
  categoryName: string;
  plannedQuantity: number;
  deliveredQuantity: number;
  pendingQuantity: number;
  emptyReturned: number;        // ✨ ADD THIS
  damagedReturned: number;      // ✨ ADD THIS
  cashCollected: number;
  itemStatus: 'Pending' | 'Partial' | 'Completed';
  remarks?: string;
  updatedAt: Date | string;
  unitPrice?: number;
  totalAmount?: number;
}
```

=============================================
PART 6: ANGULAR UI UPDATE
=============================================

FILE: Update your delivery item actuals component HTML

ADD TWO COLUMNS to the table:

```html
<table class="table">
  <thead>
    <tr>
      <th>Product</th>
      <th>Planned</th>
      <th>Delivered</th>
      <th>Pending</th>
      <th>Empty Returned</th>     <!-- ✨ ADD -->
      <th>Damaged</th>             <!-- ✨ ADD -->
      <th>Cash Collected</th>
      <th>Status</th>
    </tr>
  </thead>
  <tbody formArrayName="items">
    <tr *ngFor="let item of items.controls; let i = index" [formGroupName]="i">
      <td>{{ getProductName(i) }}</td>
      <td>{{ getPlannedQty(i) }}</td>
      <td><input type="number" formControlName="delivered" class="form-control"></td>
      <td><input type="number" formControlName="pending" class="form-control"></td>
      <td><input type="number" formControlName="emptyReturned" class="form-control"></td>  <!-- ✨ ADD -->
      <td><input type="number" formControlName="damagedReturned" class="form-control"></td> <!-- ✨ ADD -->
      <td><input type="number" formControlName="cash" class="form-control"></td>
      <td>{{ item.value.status }}</td>
    </tr>
  </tbody>
</table>
```

UPDATE FORM GROUP:

```typescript
private createItemGroup(item: DailyDeliveryItemActual) {
  return this.fb.group({
    productId: [item.productId],
    delivered: [item.deliveredQuantity, [Validators.required, Validators.min(0)]],
    pending: [item.pendingQuantity, [Validators.required, Validators.min(0)]],
    emptyReturned: [item.emptyReturned || 0, [Validators.min(0)]],      // ✨ ADD
    damagedReturned: [item.damagedReturned || 0, [Validators.min(0)]],  // ✨ ADD
    cash: [item.cashCollected, [Validators.min(0)]],
    remarks: [item.remarks || '']
  });
}
```

=============================================
PART 7: STOCK INTEGRATION UPDATE
=============================================

UPDATE sp_UpdateStockFromDeliveryReturn:

```sql
CREATE OR ALTER PROCEDURE sp_UpdateStockFromDeliveryReturn
    @DeliveryId INT
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;

    BEGIN TRY
        BEGIN TRANSACTION;

        -- Sum empty and damaged from item-level actuals (per product)
        INSERT INTO StockTransactions (
            ProductId, 
            TransactionType, 
            FilledChange, 
            EmptyChange, 
            DamagedChange, 
            ReferenceId, 
            ReferenceType, 
            Remarks, 
            CreatedBy
        )
        SELECT 
            a.ProductId,
            'DeliveryCompleted',
            0,  -- No change to filled
            a.EmptyReturned,    -- ✨ Product-specific empty returns
            a.DamagedReturned,  -- ✨ Product-specific damaged returns
            a.DeliveryId,
            'Delivery',
            'Delivery #' + CAST(a.DeliveryId AS NVARCHAR(10)) + ' completed',
            'System'
        FROM DailyDeliveryItemActuals a
        WHERE a.DeliveryId = @DeliveryId
        AND (a.EmptyReturned > 0 OR a.DamagedReturned > 0);  -- Only if there are returns

        -- Update stock register per product
        UPDATE sr
        SET 
            EmptyStock = sr.EmptyStock + a.EmptyReturned,
            DamagedStock = sr.DamagedStock + a.DamagedReturned,
            LastUpdated = GETDATE(),
            UpdatedBy = 'DeliveryReturn'
        FROM StockRegister sr
        INNER JOIN DailyDeliveryItemActuals a ON sr.ProductId = a.ProductId
        WHERE a.DeliveryId = @DeliveryId
        AND (a.EmptyReturned > 0 OR a.DamagedReturned > 0);

        SELECT 1 AS success, 'Stock updated from delivery returns' AS message;

        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
            
        SELECT 0 AS success, ERROR_MESSAGE() AS message;
    END CATCH
END
GO
```

=============================================
IMPLEMENTATION CHECKLIST
=============================================

DATABASE:
[ ] 1. Execute SQL migration script (adds EmptyReturned, DamagedReturned columns)
[ ] 2. Update sp_GetDeliveryItemActuals (returns new columns)
[ ] 3. Update sp_UpdateDeliveryItemActuals (accepts new columns in JSON)
[ ] 4. Update sp_UpdateStockFromDeliveryReturn (uses product-level returns)

ANGULAR:
[ ] 5. Update DailyDeliveryItemActual model (add 2 properties)
[ ] 6. Update delivery actuals component HTML (add 2 columns)
[ ] 7. Update form group (add 2 form controls)
[ ] 8. Test: Enter empty/damaged returns per product

BACKEND API:
[ ] 9. No changes needed (JSON parsing handles new fields automatically)

TESTING:
[ ] 10. Create delivery with 2 products
[ ] 11. Enter actuals with different empty/damaged per product
[ ] 12. Close delivery
[ ] 13. Verify Stock Register shows correct empty/damaged per product

=============================================
CLARIFICATION NEEDED FROM BUSINESS
=============================================

QUESTION 1: What does "NoOfDeliveries" column represent?
OPTIONS:
A. Number of delivery addresses/stops
B. Number of successful delivery completions
C. Number of delivery trips required for this product
D. Same as NoOfInvoices (can be removed if duplicate)

RECOMMENDATION: If same as NoOfInvoices, consider removing to simplify

QUESTION 2: Can accessories have empty/damaged returns?
- Gas Regulators, Rubber Tubes don't return empty
- Only cylinders have empty returns
- But accessories can be damaged

SUGGESTION: Add validation:
- EmptyReturned only allowed for cylinder products
- DamagedReturned allowed for all products

This ensures complete product-level tracking for stock management!
